new Community, commMap, stdout(`rho:io:stdout`), lookup(`rho:registry:lookup`), 
insertArbitrary(`rho:registry:insertArbitrary`), ret, ack in {
    insertArbitrary!(*Community,*ret) |
    for ( uri <- ret ) {
       stdout!(["#define $Community",*uri])
    } |
    commMap!({}) |
    contract Community (@"new", @name, return) = {
        new admin, methods, userlist, infoCh, ret in {
            userlist!([]) | methods!({}) |
            for (@comms <- commMap ) {
                if ( comms.get(name) != Nil ) {
                    stdout!("error: community with that name already exists") |
                    commMap!(comms) |
                    return!(Nil)
                } else {
                  stdout!("creating community.") |
                  lookup!($Directory,*ret) |
                  for ( Directory <- ret ) {
                    stdout!(["got directory", *Directory]) |
                    Directory!(*ret) |
                    for ( @{"read": *read, "write": *write, "grant": *grant, ..._ } <- ret ) {
                      commMap!(comms.union({name: *infoCh})) |
                      infoCh!({"name": name}) |
                      return!({"admin": *admin, "read": *read, "write": *write, "grant": *grant}) |
                      contract admin(@"add info", @key, @value, return) = {
                        for (info <- infoCh) {
                          infoCh!(*info.set(key, value))
                        }
                      } |
                      contract admin(@"add user", @username, @inbox, return) = {
                        //TODO see if already a member
                        for ( @list <- userlist) {
                          userlist!(list.slice(1,list.length()) ++ username ++ list.nth(0)) |
                          stdout!(list.slice(1,list.length()) ++ username ++ list.nth(0)) |
                          write!(username, {"inbox": inbox, "delegate": list.nth(0)}, *stdout)
                        } |
                        grant!(username, *ret) |
                        for ( updateself <- ret ) {
                          return!({"selfupdate": *updateself})
                        }
                       }
                     }
                   }
                 }
              }
            }
          } |
    contract Community (@"lookup", @name, return) = {
        for ( @{map /\  {name: *infoCh, ..._}} <- commMap ) {
          commMap!(map) |
          for ( info <- infoCh ) {
            //stdout!(*info) |
            infoCh!(*info) |
            return!(*info)
          }
        }
      } |
    contract Community (@"lookup", return) = {
        for ( @map <- commMap ) {
          //stdout!(map) |
          commMap!(map) |
          return!(map)
        }
    } |
    Community!("new","test", *ret) |
    Community!("new","test2", *ret) |
    for ( @{"admin": admin, "read": read, "write": write, "grant": grant} <- ret; _ <- ret ) {
      stdout!("got em") |
      Community!("lookup","test",*stdout) |
      Community!("lookup","test2",*stdout) |
      Community!("lookup",*stdout) |
      Community!("new","test", *stdout) |
      admin|("add user","jim","xxxxx", *ret) |
      for ( _ <- ret ) {
       Community!("lookup","test",*stdout) |
       Community!("lookup","test2",*stdout)
      }
    }
}

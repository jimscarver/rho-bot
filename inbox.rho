new $stdout, Inbox in {
stdout!("begin") |
contract Inbox(capabilities) = {
  new read, write, peek, box in {
    capabilities!(bundle+{*read}, bundle+{*write}, bundle+{*peek}) |
    box!(Nil) |

    contract read(ret) = {
      for (items <- box) {
        ret!(*items) |
        box!(*items)
      }
    } |
    contract read(type,ret) = {
      //stdout!(["type",*type]) |
      for (items <- box) {
        match (*items) {
          {[=*type, ...item] | rest} => {
            //stdout!(item) |
            ret!(item) |
            box!(rest)
          }
          _ => {box!(*items) | ret!(Nil) | stdout!([*type,"not found"])}
        }
      }
    } |
    contract read(type,subtype,ret) = {
      //stdout!(["type",*type]) |
      for (items <- box) {
        match (*items) {
          {[=*type, =*subtype, ...item] | rest} => {
            //stdout!(item) |
            ret!(item) |
            box!(rest)
          }
          _ => {
            box!(*items)|ret!(Nil) | stdout!([*type, *subtype, "not found"])
          }
        }
      }
    } |

    contract peek(ret) = {
      for (items <- box) {
        ret!(*items) |
        box!(*items)
      }
    } |
    contract peek(type,ret) = {
      //stdout!(["type",*type]) |
      for (items <- box) {
        match (*items) {
          {[=*type, ...item] | rest} => {
            //stdout!(item) |
            ret!(item) |
            box!(*items)
          }
          _ => {box!(*items) | ret!(Nil) | stdout!([*type,"not found"])}
        }
      }
    } |
    contract peek(type,subtype,ret) = {
      //stdout!(["type",*type]) |
      for (items <- box) {
        match (*items) {
          {[=*type, =*subtype, ...item] | rest} => {
            //stdout!(item) |
            ret!(item) |
            box!(*items)
          }
          _ => {
            box!(*items)|ret!(Nil) | stdout!([*type, *subtype, "not found"])
          }
        }
      }
    } |

    contract write(@message,ret) = {
       for (items <- box) {
         /*
         match *items {
          {[type /\ {=message}.nth(0), subtype /\ {=message}.nth(1), map  ] | more } => {
              box!([type, subtype, message.nth(2).union(map)] | more) |
              ret!("added.")
          } xx}
          */
         match message {
          [type, subtype, map /\ {a: b, ..._} ] => {
            match *items {
              {[=type, =subtype, oldmap] | more } => {
                box!([type, subtype, map.union(oldmap)] | more) |
                /* stdout!(map.union(oldmap)) | */
                ret!("added.")
              }
              _ => {
                box!(*items | message) |
                ret!("sent...")
              }
            }
          }
          _ => {
            //stdout!([*message, *items]) |
            box!(*items | message) |
            ret!("sent.")
          }
        }
      }
    }
  }
} |
new capabilities, ack, ack1, message, uriCh, $insertArbitrary in {
  stdout!("hello world") |
  insertArbitrary!(*Inbox, *uriCh)|
  for (uri <- uriCh) {
    stdout!(["#define $Inbox", *uri])
  } |
  Inbox!(*capabilities) |
  for (receive, send, peek <- capabilities) {
    stdout!("received capabilities") |
    send!(["values","test", {"a": "b", "b": "c"}], *ack) |
    send!(["chat",$myusername ++ ": Watson come quickly!"], *ack) |
    send!(["chat",$myusername, "Watson come now!"], *ack) |
    send!(["chat","hello world"], *ack) |
    for ( _ <- ack; _ <- ack; _ <- ack; _ <- ack) {
      send!(["values","test", {"a": "x", "c": "d"}], *stdout) |
      //receive!(["chat", _ ], *message) |
      receive!("chat", *message) |
      for ( text <- message ) {
        stdout!(*text)
      } |
      receive!("chat", $myusername, *message) |
      for ( text <- message ) {
        stdout!(*text)
      } |
      receive!("chat", *message) |
      for ( text <- message ) {
        stdout!(*text)
      }
    }
  }
}}
